dotnet ef dbcontext scaffold "Server=Jack-Blue;Port=3306;Database=zestybite;Uid=jack;Pwd=jack1624.," MySql.EntityFrameworkCore -o Models -c ZestyBiteDbContext

Tình huống 1: Không có Repository (Tất cả logic trong Service Layer)

Trong tình huống này, bạn sẽ thấy rằng các chức năng như Authentication, Authorization, và Caching phải được tích hợp trực tiếp vào Service Layer, làm cho lớp này trở nên phức tạp hơn.

1.1. TodoService (Không có Repository)

Dưới đây là một TodoService có đầy đủ các tính năng như Authentication, Authorization, và Caching.

public class TodoService : ITodoService
{
    private readonly TodoDbContext _context;
    private readonly ICacheService _cacheService;
    private readonly IUserService _userService;
    private readonly ILogger<TodoService> _logger;
    private readonly IHttpContextAccessor _httpContextAccessor;

    public TodoService(
        TodoDbContext context,
        ICacheService cacheService,
        IUserService userService,
        ILogger<TodoService> logger,
        IHttpContextAccessor httpContextAccessor)
    {
        _context = context;
        _cacheService = cacheService;
        _userService = userService;
        _logger = logger;
        _httpContextAccessor = httpContextAccessor;
    }

    // Method để lấy tất cả Todo items
    public async Task<IEnumerable<TodoItem>> GetTodoItemsAsync()
    {
        var userId = _httpContextAccessor.HttpContext.User.Identity.Name;
        _logger.LogInformation($"User {userId} is fetching Todo items.");

        // Kiểm tra cache trước
        var cacheKey = $"todos_{userId}";
        var cachedTodos = _cacheService.Get<IEnumerable<TodoItem>>(cacheKey);
        if (cachedTodos != null)
        {
            _logger.LogInformation("Returning todos from cache.");
            return cachedTodos;
        }

        // Kiểm tra quyền của người dùng
        if (!_userService.HasPermission(userId, "ViewTodos"))
        {
            throw new UnauthorizedAccessException("User does not have permission to view todos.");
        }

        // Nếu không có trong cache, truy vấn cơ sở dữ liệu
        var todos = await _context.TodoItems.ToListAsync();

        // Lưu kết quả vào cache
        _cacheService.Set(cacheKey, todos, TimeSpan.FromMinutes(5));
        
        return todos;
    }

    // Các phương thức CRUD khác
}

1.2. Các Service phụ trợ

ICacheService: Giả sử bạn có một dịch vụ Cache đơn giản.

public interface ICacheService
{
    T Get<T>(string key);
    void Set(string key, object value, TimeSpan expiry);
}

IUserService: Một service để kiểm tra quyền của người dùng.

public interface IUserService
{
    bool HasPermission(string userId, string permission);
}

1.3. TodoController

Controller vẫn rất đơn giản, chỉ gọi trực tiếp vào Service Layer để thực hiện nghiệp vụ.

[Route("api/[controller]")]
[ApiController]
public class TodoController : ControllerBase
{
    private readonly ITodoService _todoService;

    public TodoController(ITodoService todoService)
    {
        _todoService = todoService;
    }

    [HttpGet]
    public async Task<IActionResult> GetTodos()
    {
        try
        {
            var todos = await _todoService.GetTodoItemsAsync();
            return Ok(todos);
        }
        catch (UnauthorizedAccessException ex)
        {
            return Unauthorized(ex.Message);
        }
        catch (Exception ex)
        {
            return StatusCode(500, ex.Message);
        }
    }
}


=======================================================================================================================

Tình huống 2: Có Repository Layer (Tách biệt Repository và Service)

Khi sử dụng Repository Layer, việc tách biệt logic truy vấn dữ liệu khỏi nghiệp vụ và các tính năng như Authentication, Authorization, và Caching sẽ giúp bạn tổ chức code tốt hơn. 

Trong tình huống này, các tính năng phụ trợ như Authentication và Caching sẽ được xử lý ở các lớp riêng biệt và không làm phức tạp logic nghiệp vụ trong Service Layer.

2.1. TodoRepository

Repository sẽ chỉ xử lý truy vấn cơ sở dữ liệu mà không liên quan đến các tính năng phụ trợ như caching hay authentication.

public class TodoRepository : ITodoRepository
{
    private readonly TodoDbContext _context;

    public TodoRepository(TodoDbContext context)
    {
        _context = context;
    }

    public async Task<IEnumerable<TodoItem>> GetAllTodosAsync()
    {
        return await _context.TodoItems.ToListAsync();
    }

    // Các phương thức CRUD khác
}

2.2. TodoService

Trong Service Layer, bạn chỉ xử lý các nghiệp vụ và gọi Repository để truy vấn dữ liệu. Các tính năng như Authentication, Authorization, và Caching sẽ được thực hiện thông qua các service khác, không làm phức tạp TodoService.

public class TodoService : ITodoService
{
    private readonly ITodoRepository _todoRepository;
    private readonly ICacheService _cacheService;
    private readonly IUserService _userService;
    private readonly IHttpContextAccessor _httpContextAccessor;
    private readonly ILogger<TodoService> _logger;

    public TodoService(
        ITodoRepository todoRepository,
        ICacheService cacheService,
        IUserService userService,
        IHttpContextAccessor httpContextAccessor,
        ILogger<TodoService> logger)
    {
        _todoRepository = todoRepository;
        _cacheService = cacheService;
        _userService = userService;
        _httpContextAccessor = httpContextAccessor;
        _logger = logger;
    }

    public async Task<IEnumerable<TodoItem>> GetTodoItemsAsync()
    {
        var userId = _httpContextAccessor.HttpContext.User.Identity.Name;
        _logger.LogInformation($"User {userId} is fetching Todo items.");

        // Kiểm tra quyền của người dùng
        if (!_userService.HasPermission(userId, "ViewTodos"))
        {
            throw new UnauthorizedAccessException("User does not have permission to view todos.");
        }

        // Kiểm tra cache trước
        var cacheKey = $"todos_{userId}";
        var cachedTodos = _cacheService.Get<IEnumerable<TodoItem>>(cacheKey);
        if (cachedTodos != null)
        {
            _logger.LogInformation("Returning todos from cache.");
            return cachedTodos;
        }

        // Nếu không có trong cache, truy vấn cơ sở dữ liệu
        var todos = await _todoRepository.GetAllTodosAsync();

        // Lưu kết quả vào cache
        _cacheService.Set(cacheKey, todos, TimeSpan.FromMinutes(5));
        
        return todos;
    }

    // Các phương thức CRUD khác
}

2.3. TodoController

TodoController vẫn giữ nguyên như trước, chỉ cần gọi các phương thức trong TodoService để thực hiện nghiệp vụ. Controller chỉ cần tập trung vào xử lý HTTP request và response.

[Route("api/[controller]")]
[ApiController]
public class TodoController : ControllerBase
{
    private readonly ITodoService _todoService;

    public TodoController(ITodoService todoService)
    {
        _todoService = todoService;
    }

    [HttpGet]
    public async Task<IActionResult> GetTodos()
    {
        try
        {
            var todos = await _todoService.GetTodoItemsAsync();
            return Ok(todos);
        }
        catch (UnauthorizedAccessException ex)
        {
            return Unauthorized(ex.Message);
        }
        catch (Exception ex)
        {
            return StatusCode(500, ex.Message);
        }
    }
}

======================================================================

public class TodoRepository : ITodoRepository
{
    private readonly TodoDbContext _context;

    public TodoRepository(TodoDbContext context)
    {
        _context = context;
    }

    // CREATE: Thêm một TodoItem mới
    public async Task<TodoItem> AddAsync(TodoItem todoItem)
    {
        _context.TodoItems.Add(todoItem);  // Thêm vào DbSet TodoItems
        await _context.SaveChangesAsync(); // Lưu thay đổi vào cơ sở dữ liệu
        return todoItem;  // Trả về đối tượng TodoItem vừa thêm
    }

    // READ: Lấy tất cả Todo items chưa hoàn thành
    public async Task<IEnumerable<TodoItem>> GetIncompleteAsync()
    {
        return await _context.TodoItems
                             .Where(todo => !todo.IsCompleted)
                             .OrderBy(todo => todo.CreatedDate)
                             .ToListAsync();
    }

    // READ: Lấy tất cả Todo items đã hoàn thành
    public async Task<IEnumerable<TodoItem>> GetCompletedAsync()
    {
        return await _context.TodoItems
                             .Where(todo => todo.IsCompleted)
                             .OrderByDescending(todo => todo.CompletedDate)
                             .ToListAsync();
    }

    // READ: Lấy một TodoItem theo ID
    public async Task<TodoItem> GetByIdAsync(int id)
    {
        return await _context.TodoItems
                             .FirstOrDefaultAsync(todo => todo.Id == id); // Trả về null nếu không tìm thấy
    }

    // UPDATE: Cập nhật TodoItem
    public async Task<TodoItem> UpdateAsync(TodoItem todoItem)
    {
        var existingTodo = await _context.TodoItems.FindAsync(todoItem.Id);
        if (existingTodo == null) return null;

        // Cập nhật các trường dữ liệu
        existingTodo.Title = todoItem.Title;
        existingTodo.Description = todoItem.Description;
        existingTodo.IsCompleted = todoItem.IsCompleted;
        existingTodo.CompletedDate = todoItem.CompletedDate;

        await _context.SaveChangesAsync(); // Lưu thay đổi vào cơ sở dữ liệu
        return existingTodo; // Trả về TodoItem đã cập nhật
    }

    // DELETE: Xóa TodoItem
    public async Task<bool> DeleteAsync(int id)
    {
        var todoItem = await _context.TodoItems.FindAsync(id);
        if (todoItem == null) return false;

        _context.TodoItems.Remove(todoItem); // Xóa TodoItem khỏi DbSet
        await _context.SaveChangesAsync(); // Lưu thay đổi vào cơ sở dữ liệu
        return true; // Trả về true nếu xóa thành công
    }

    // Tìm TodoItem theo tiêu đề (Tìm kiếm)
    public async Task<IEnumerable<TodoItem>> SearchByTitleAsync(string title)
    {
        return await _context.TodoItems
                             .Where(todo => todo.Title.Contains(title))
                             .OrderBy(todo => todo.CreatedDate)
                             .ToListAsync();
    }
}


====================================

. tôi muốn biết trong mỗi một các interface trên gồm những gì
2. Luôn luôn sử dụng TypedResult cho controllers
3. Phải tận dụng DTO nếu khả thi để tôi có thể hiểu hơn về cách code kết hợp cùng với DTO
4. Luôn đóng vai trò bạn là 1 chuyên gia với hơn 20 yoe về lĩnh vực dotnet này bạn là 1 pm devops nói chung là bạn rất giỏi về nhiều lĩnh vực và chuyên sâu có thể giải quyết và demo được các dự án phức tạo => dựa vào đó hãy demo cho tôi thêm cách để tận dụng thêm 2 folder mới đó là Filters và Middlewares

public interface ITodoRepository
{
    Task<TodoItem> AddAsync(TodoItem todoItem);
    Task<IEnumerable<TodoItem>> GetIncompleteAsync();
    Task<IEnumerable<TodoItem>> GetCompletedAsync();
    Task<TodoItem> GetByIdAsync(int id);
    Task<TodoItem> UpdateAsync(TodoItem todoItem);
    Task<bool> DeleteAsync(int id);
    Task<IEnumerable<TodoItem>> SearchByTitleAsync(string title);
}


public interface ITodoService
{
    Task<TypedResult<IEnumerable<TodoItemDTO>>> GetTodoItemsAsync();
    Task<TypedResult<TodoItemDTO>> GetTodoByIdAsync(int id);
    Task<TypedResult<TodoItemDTO>> AddTodoAsync(TodoItemDTO todoItemDto);
    Task<TypedResult<TodoItemDTO>> UpdateTodoAsync(TodoItemDTO todoItemDto);
    Task<TypedResult<bool>> DeleteTodoAsync(int id);
}


[Route("api/[controller]")]
[ApiController]
public class TodoController : ControllerBase
{
    private readonly ITodoService _todoService;

    public TodoController(ITodoService todoService)
    {
        _todoService = todoService;
    }

    [HttpGet]
    public async Task<IActionResult> GetTodos()
    {
        var result = await _todoService.GetTodoItemsAsync();
        if (result.Success)
        {
            return Ok(result.Data);  // Return list of TodoItemsDTO
        }

        return BadRequest(result.Message);  // Return error message
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetTodoById(int id)
    {
        var result = await _todoService.GetTodoByIdAsync(id);
        if (result.Success)
        {
            return Ok(result.Data);  // Return TodoItemDTO
        }

        return NotFound(result.Message);
    }

    [HttpPost]
    public async Task<IActionResult> AddTodo([FromBody] TodoItemDTO todoItemDto)
    {
        var result = await _todoService.AddTodoAsync(todoItemDto);
        if (result.Success)
        {
            return CreatedAtAction(nameof(GetTodoById), new { id = result.Data.Id }, result.Data);
        }

        return BadRequest(result.Message);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateTodo(int id, [FromBody] TodoItemDTO todoItemDto)
    {
        todoItemDto.Id = id;
        var result = await _todoService.UpdateTodoAsync(todoItemDto);
        if (result.Success)
        {
            return Ok(result.Data);
        }

        return BadRequest(result.Message);
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteTodo(int id)
    {
        var result = await _todoService.DeleteTodoAsync(id);
        if (result.Success)
        {
            return NoContent();  // No content after successful delete
        }

        return BadRequest(result.Message);
    }
}

/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
A. Custom Authorization Filter

Giả sử bạn muốn kiểm tra quyền truy cập của người dùng trước khi cho phép truy cập vào controller. Bạn có thể tạo một filter.



public class AuthorizationFilter : IAsyncActionFilter
{
    private readonly IUserService _userService;

    public AuthorizationFilter(IUserService userService)
    {
        _userService = userService;
    }

    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        var userId = context.HttpContext.User.Identity.Name;
        if (!_userService.HasPermission(userId, "ViewTodos"))
        {
            context.Result = new UnauthorizedResult();
            return;
        }

        await next();
    }
}

[ServiceFilter(typeof(AuthorizationFilter))]
[HttpGet]
public async Task<IActionResult> GetTodos()
{
    var result = await _todoService.GetTodoItemsAsync();
    return result.Success ? Ok(result.Data) : BadRequest(result.Message);
}

/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/
B. Custom Middleware (Logging)

Giả sử bạn muốn log tất cả các request và response vào một file log. Bạn có thể tạo một middleware để làm điều này.



public class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestLoggingMiddleware> _logger;

    public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        _logger.LogInformation($"Incoming Request: {context.Request.Method} {context.Request.Path}");
        await _next(context);
        _logger.LogInformation($"Outgoing Response: {context.Response.StatusCode}");
    }
}

public static IHostBuilder CreateHostBuilder(string[] args) =>
    Host.CreateDefaultBuilder(args)
        .ConfigureWebHostDefaults(webBuilder =>
        {
            webBuilder.Configure(app =>
            {
                app.UseMiddleware<RequestLoggingMiddleware>();
                app.UseRouting();
                app.UseEndpoints(endpoints => { endpoints.MapControllers(); });
            });
        });

============>>>>>>>>> middleware co the del can

=====================================================================================================================================================================

Bước 4: Cấu hình Dependency Injection trong Program.cs (Hoặc Startup.cs)
ASP.NET Core sử dụng Dependency Injection container để quản lý vòng đời của các đối tượng và inject chúng vào các lớp cần thiết.

Ở đây, bạn sẽ cấu hình TodoRepository với vòng đời Scoped. Điều này có nghĩa là mỗi HTTP request sẽ có một thể hiện duy nhất của TodoRepository và TodoDbContext.

public class Program
{
    public static void Main(string[] args)
    {
        CreateHostBuilder(args).Build().Run();
    }

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.ConfigureServices((context, services) =>
                {
                    // Thêm DbContext với Connection String
                    services.AddDbContext<TodoDbContext>(options =>
                        options.UseSqlServer(context.Configuration.GetConnectionString("DefaultConnection")));

                    // Thêm TodoRepository với vòng đời Scoped
                    services.AddScoped<ITodoRepository, TodoRepository>();

                    // Thêm các dịch vụ khác như controller, Swagger, v.v.
                    services.AddControllers();
                });

                webBuilder.Configure(app =>
                {
                    app.UseRouting();
                    app.UseEndpoints(endpoints =>
                    {
                        endpoints.MapControllers();
                    });
                });
            });
}


/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/

OOP Standard

Cải tiến: Để tuân thủ chặt chẽ nguyên lý Encapsulation, chúng ta có thể làm cho các thuộc tính trong model TodoItem là private hoặc protected, và chỉ cung cấp các phương thức getter/setter hoặc sử dụng Validation để kiểm tra dữ liệu trước khi gán vào thuộc tính.

public class TodoItem
{
    public int Id { get; private set; }  // Không cho phép thay đổi ID sau khi đã tạo
    public string Title { get; private set; }
    public string Description { get; private set; }
    public bool IsCompleted { get; set; }
    public DateTime CreatedDate { get; private set; }

    // Constructor để tạo mới TodoItem
    public TodoItem(string title, string description)
    {
        Title = title;
        Description = description;
        CreatedDate = DateTime.UtcNow;
    }

    // Phương thức để cập nhật các thuộc tính này
    public void UpdateTitle(string title)
    {
        if (string.IsNullOrEmpty(title)) throw new ArgumentException("Title cannot be empty");
        Title = title;
    }

    public void UpdateDescription(string description)
    {
        if (string.IsNullOrEmpty(description)) throw new ArgumentException("Description cannot be empty");
        Description = description;
    }
}

public interface ITodoRepository
{
    Task<IEnumerable<TodoItem>> GetAllAsync();
    Task<TodoItem> GetByIdAsync(int id);
    Task<TodoItem> AddAsync(TodoItem todoItem);
    Task<bool> UpdateAsync(TodoItem todoItem);
    Task<bool> DeleteAsync(int id);
}



=============>>>>>>>>>>>

APPLICATION FOR TYPEDRESULT

public class TypedResult<T>
{
    public bool Success { get; set; }
    public string Message { get; set; }
    public T Data { get; set; }

    public TypedResult(bool success, string message, T data = default)
    {
        Success = success;
        Message = message;
        Data = data;
    }

    // Static helpers for success and failure
    public static TypedResult<T> SuccessResult(T data) =>
        new TypedResult<T>(true, "Request was successful", data);

    public static TypedResult<T> FailureResult(string message) =>
        new TypedResult<T>(false, message);
}


[Route("api/[controller]")]
[ApiController]
public class TodoController : ControllerBase
{
    private readonly ITodoService _todoService;

    public TodoController(ITodoService todoService)
    {
        _todoService = todoService;
    }

    // GET: api/todo
    [HttpGet]
    public async Task<TypedResult<IEnumerable<TodoItemDTO>>> GetTodos()
    {
        var result = await _todoService.GetTodoItemsAsync();
        if (result.Success)
        {
            return TypedResult<IEnumerable<TodoItemDTO>>.SuccessResult(result.Data);  // Trả về danh sách TodoItemsDTO
        }

        return TypedResult<IEnumerable<TodoItemDTO>>.FailureResult(result.Message);  // Trả về lỗi nếu không thành công
    }

    // GET: api/todo/{id}
    [HttpGet("{id}")]
    public async Task<TypedResult<TodoItemDTO>> GetTodoById(int id)
    {
        var result = await _todoService.GetTodoByIdAsync(id);
        if (result.Success)
        {
            return TypedResult<TodoItemDTO>.SuccessResult(result.Data);  // Trả về TodoItemDTO
        }

        return TypedResult<TodoItemDTO>.FailureResult(result.Message);  // Trả về lỗi nếu không tìm thấy
    }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // POST: api/todo
    [HttpPost]
    public async Task<TypedResult<TodoItemDTO>> AddTodo([FromBody] TodoItemDTO todoItemDto)
    {
        var result = await _todoService.AddTodoAsync(todoItemDto);
        if (result.Success)
        {
            return TypedResult<TodoItemDTO>.SuccessResult(result.Data);  // Trả về TodoItemDTO đã tạo
        }

        return TypedResult<TodoItemDTO>.FailureResult(result.Message);  // Trả về lỗi nếu không thành công
    }
/**************************************************************************************************************************
   public async Task<TodoItem> AddAsync(TodoItem todoItem)
    {
        _context.TodoItems.Add(todoItem);  // Thêm vào DbSet TodoItems
        await _context.SaveChangesAsync(); // Lưu thay đổi vào cơ sở dữ liệu
        return todoItem;  // Trả về đối tượng TodoItem vừa thêm
    }
***************************************************************************************************************************/
    // PUT: api/todo/{id}
    [HttpPut("{id}")]
    public async Task<TypedResult<TodoItemDTO>> UpdateTodo(int id, [FromBody] TodoItemDTO todoItemDto)
    {
        todoItemDto.Id = id;
        var result = await _todoService.UpdateTodoAsync(todoItemDto);
        if (result.Success)
        {
            return TypedResult<TodoItemDTO>.SuccessResult(result.Data);  // Trả về TodoItemDTO đã cập nhật
        }

        return TypedResult<TodoItemDTO>.FailureResult(result.Message);  // Trả về lỗi nếu không thành công
    }

    // DELETE: api/todo/{id}
    [HttpDelete("{id}")]
    public async Task<TypedResult<string>> DeleteTodo(int id) // nen find truoc xem ton tai hay khong 
    {
        var result = await _todoService.DeleteTodoAsync(id);
        if (result.Success)
        {
            return TypedResult<string>.SuccessResult("Todo item deleted successfully");
        }

        return TypedResult<string>.FailureResult(result.Message);  // Trả về lỗi nếu không thành công
    }
}


*******************************************************************************************************************************************************
*******************************************************************************************************************************************************

public class TodoItem
{
    public int Id { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public bool IsCompleted { get; set; }
    public DateTime CreatedDate { get; set; }
    public DateTime? CompletedDate { get; set; }

    [Timestamp] // Thuộc tính này sẽ giúp EF Core nhận diện trường phiên bản
    public byte[] RowVersion { get; set; } // Trường theo dõi sự thay đổi dữ liệu
}

public async Task<TodoItem> UpdateAsync(TodoItem todoItem)
{
    var existingTodo = await _context.TodoItems.FindAsync(todoItem.Id);
    if (existingTodo == null) return null;

    // So sánh RowVersion để kiểm tra xem có sự thay đổi dữ liệu không
    if (!existingTodo.RowVersion.SequenceEqual(todoItem.RowVersion))
    {
        // Nếu RowVersion không khớp, xảy ra xung đột
        throw new DbUpdateConcurrencyException("Dữ liệu đã bị thay đổi bởi người dùng khác.");
    }

    // Cập nhật các trường dữ liệu
    existingTodo.Title = todoItem.Title;
    existingTodo.Description = todoItem.Description;
    existingTodo.IsCompleted = todoItem.IsCompleted;
    existingTodo.CompletedDate = todoItem.CompletedDate;

    // Lưu thay đổi vào cơ sở dữ liệu
    await _context.SaveChangesAsync();
    return existingTodo;
}

[HttpPut("{id}")]
public async Task<IActionResult> UpdateTodo(int id, TodoItem todoItem)
{
    if (id != todoItem.Id)
    {
        return BadRequest("ID không hợp lệ.");
    }

    try
    {
        var updatedTodo = await _todoService.UpdateAsync(todoItem);
        return Ok(updatedTodo);
    }
    catch (DbUpdateConcurrencyException)
    {
        return Conflict("Dữ liệu đã thay đổi. Vui lòng thử lại.");
    }
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Các loại Filters trong ASP.NET Core
	1. Authorization Filters: Xử lý xác thực (authentication) và phân quyền (authorization).
	2. Action Filters: Can thiệp vào logic của action method trước và sau khi thực thi.
	3. Result Filters: Xử lý kết quả trả về từ action method, có thể là nội dung của HTTP response.
	4. Exception Filters: Xử lý ngoại lệ (exception) nếu action method xảy ra lỗi.
	5. Resource Filters: Can thiệp vào các tài nguyên trước khi chúng được nạp vào.

/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=
/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=
/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=/*-+=

public interface IProductRepository
{
    Task AddProductsAsync(List<Product> products);
}

public class ProductRepository : IProductRepository
{
    private readonly DbContext _dbContext; // Giả lập DbContext của EF Core

    public ProductRepository(DbContext dbContext)
    {
        _dbContext = dbContext;
    }

    public async Task AddProductsAsync(List<Product> products)
    {
        // Sử dụng EF Core để thêm danh sách sản phẩm
        await _dbContext.Products.AddRangeAsync(products);
        await _dbContext.SaveChangesAsync();
    }
}

public interface IProductService
{
    Task AddProductsAsync(List<Product> products);
}

public class ProductService : IProductService
{
    private readonly IProductRepository _repository;

    public ProductService(IProductRepository repository)
    {
        _repository = repository;
    }

    public async Task AddProductsAsync(List<Product> products)
    {
        // Thực hiện logic bổ sung trước khi thêm
        foreach (var product in products)
        {
            if (string.IsNullOrWhiteSpace(product.Name))
                throw new ArgumentException("Product name cannot be empty.");

            if (product.Price <= 0)
                throw new ArgumentException($"Invalid price for product {product.Name}");
        }

        // Gọi repository để lưu dữ liệu
        await _repository.AddProductsAsync(products);
    }
}

[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductService _productService;

    public ProductsController(IProductService productService)
    {
        _productService = productService;
    }

    [HttpPost]
    [Route("add-multiple")]
    public async Task<IActionResult> AddProducts([FromBody] List<Product> products)
    {
        try
        {
            await _productService.AddProductsAsync(products);
            return Ok("Products added successfully!");
        }
        catch (Exception ex)
        {
            return BadRequest(new { Message = ex.Message });
        }
    }
}

Dưới đây là ví dụ cụ thể để tạo một tính năng Sign-In trong RESTful API.

